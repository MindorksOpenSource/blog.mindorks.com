<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns#" xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <title>
   Improving Android app performance with Benchmarking
  </title>
  <meta charset="utf-8"/>
  <meta content="IE=edge" http-equiv="X-UA-Compatible"/>
  <meta content="minimum-scale=1,initial-scale=1,width=device-width,shrink-to-fit=no" name="viewport"/>
  <link href="https://blog.mindorks.com/improving-android-app-performance-with-benchmarking" rel="canonical"/>
  <meta content="986249072156-dabps0lf90smluddrk5rkqsdjghk3hd3.apps.googleusercontent.com" name="google-signin-client_id"/>
  <meta content="android, learn android app development, android app development courses, android blogs, android tutorial" name="keywords"/>
  <meta content="Improving Android app performance with Benchmarking" property="og:title"/>
  <meta content="website" property="og:type"/>
  <meta content="https://blog.mindorks.com/improving-android-app-performance-with-benchmarking" property="og:url"/>
  <meta content="/images/improving-android-app-performance-with-benchmarking-banner.png" property="og:image"/>
  <meta content="In this blog, we will learn how to improve Android app performance with Benchmarking. Benchmarking is a way to measure the code that you have written for your app. For the process of benchmarking, we have one library called Jetpack Benchmark. So, we will lean each and everything related to benchmarking." property="og:description"/>
  <meta content="Improving Android app performance with Benchmarking" property="twitter:title"/>
  <meta content="In this blog, we will learn how to improve Android app performance with Benchmarking. Benchmarking is a way to measure the code that you have written for your app. For the process of benchmarking, we have one library called Jetpack Benchmark. So, we will lean each and everything related to benchmarking." name="twitter:description"/>
  <meta content="/images/improving-android-app-performance-with-benchmarking-banner.png" name="twitter:image:src"/>
  <meta content="summary_large_image" name="twitter:card"/>
  <meta content="@MindorksNextGen" name="twitter:site"/>
  <meta content="In this blog, we will learn how to improve Android app performance with Benchmarking. Benchmarking is a way to measure the code that you have written for your app. For the process of benchmarking, we have one library called Jetpack Benchmark. So, we will lean each and everything related to benchmarking." name="description"/>
  <meta content="1620001391374687" property="fb:app_id"/>
  <link href="/styles/vendor-1.8.6.css" rel="stylesheet" type="text/css"/>
  <link href="/styles/app-1.8.6.css" rel="stylesheet" type="text/css"/>
  <link as="style" href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.1/css/font-awesome.min.css" onload='this.onload=null,this.rel="stylesheet"' rel="preload"/>
  <noscript>
   <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.1/css/font-awesome.min.css" rel="stylesheet" type="text/css"/>
  </noscript>
  <script type="text/javascript">
     </script>
  <script async="" src="https://www.google-analytics.com/analytics.js" type="text/javascript">
  </script>
  <script type="text/javascript">
   window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-91686131-1","auto"),ga("require","cleanUrlTracker"),ga("require","eventTracker"),ga("require","impressionTracker"),ga("require","outboundLinkTracker"),ga("require","urlChangeTracker"),ga("require","maxScrollTracker"),ga("require","mediaQueryTracker"),ga("require","outboundFormTracker"),ga("require","outboundLinkTracker"),ga("require","pageVisibilityTracker"),ga("require","socialWidgetTracker"),ga("require","urlChangeTracker"),ga("send","pageview")
  </script>
  <script defer="defer" src="/assets/autotrack.js" type="text/javascript">
  </script>
  <script src="/assets/highlight.js" type="text/javascript">
  </script>
  <script defer="defer" src="/js/vendor-bundle-1.8.6.js" type="text/javascript">
  </script>
  <script defer="defer" src="/js/app-bundle-1.8.6.js" type="text/javascript">
  </script>
 </head>
 <body>
  <div id="root">
   <div class="screen app-load-content" data-reactroot="">
    <div class="ui centered grid">
     <div class="row" style="padding:0">
      <div class="ui fixed menu navbar huge borderless grid" style="background-color:#fff;height:60px">
      </div>
     </div>
     <div class="centered computer only row" style="padding:0">
      <div class="ui fixed top menu navbar huge borderless grid header-container" style="background-color:#fff;height:60px">
       <a class="item brand" href="/">
        <img alt="MindOrks" src="/assets/mindorks-logo.svg"/>
        <div class="header item" style="font-size:20px;padding:0;margin-left:10px">
         MindOrks
        </div>
       </a>
       <div class="right menu">
        <a class="item" href="https://janisharali.com" target="_blank">
         Mentor Ali
        </a>
        <a class="item" href="https://amitshekhar.me" target="_blank">
         Mentor Amit
        </a>
       </div>
      </div>
     </div>
     <div class="tablet only mobile only row" style="padding:0">
      <div class="ui fixed top navbar huge menu borderless" style="background-color:#fff;height:60px">
       <a class="item brand" href="/">
        <img alt="MindOrks" src="/assets/mindorks-logo.svg"/>
        <div class="header item" style="font-size:20px;padding:0;margin-left:10px">
         MindOrks
        </div>
       </a>
       <div class="item">
       </div>
      </div>
     </div>
    </div>
    <div class="header-height">
    </div>
    <div aria-live="assertive" class="redux-toastr">
     <div>
      <div class="top-left">
      </div>
      <div class="top-right">
      </div>
      <div class="top-center">
      </div>
      <div class="bottom-left">
      </div>
      <div class="bottom-right">
      </div>
      <div class="bottom-center">
      </div>
     </div>
    </div>
    <div class="content-container theme">
     <div class="ui centered one column grid" style="padding-bottom:80px;background-color:#fff">
      <div class="ten wide computer fifteen wide mobile fifteen wide tablet column" style="margin-top:50px">
       <div>
        <div class="blog-page-author">
         <div class="ui small header">
          <img alt="Admin MindOrks" class="ui circular image" src="https://s3.ap-south-1.amazonaws.com/mindorks/website/mindorks-admin.png"/>
          <div class="content">
           Admin MindOrks
           <div class="sub header" style="margin-top:5px">
            13th September 2019
           </div>
          </div>
         </div>
        </div>
        <div id="content">
         <article class="template">
          <div class="postContent">
           <div class="notesSource">
            <div class="postField postField--body" id="editor">
             <section class="section--first section--last">
              <div class="section-divider layoutSingleColumn-template">
               <hr class="section-divider"/>
              </div>
              <div class="section-content">
               <div class="section-inner layoutSingleColumn-template">
                <div>
                 <h1 class="graf--h1">
                  Improving Android app performance with Benchmarking
                 </h1>
                 <div class="graf-image graf-caption">
                  <img alt="Improving Android app performance with Benchmarking" class="graf-image" src="/images/improving-android-app-performance-with-benchmarking-banner.png"/>
                 </div>
                 <p class="graf--p">
                  Hello, all the Android developers here. Let’s start with some question. How many of you have your apps published on Play Store? Not on the play store? Ok, how many of you have built some application that is being used by more than 100 users? Have you taken the feedback? Is everyone satisfied with the app performance? By app performance, I mean to ask the smoothness of the app i.e. the working of the application without having any lagggggggg. Oh, the lagging of an application depends on the device that the user is using. Is it so? Yeah, it is so, but you can improve the performance of your app by improving your code(irrespective of the device configuration). You heard it right :)
                 </p>
                 <p class="graf--p">
                  In this blog, we will learn how you can improve the Android app performance with Benchmarking. What is this Benchmarking? Hold on! we will learn step by step. Here is the timeline of today’s blog.
                 </p>
                 <ol>
                  <li>
                   Code measurement
                  </li>
                  <li>
                   What is Benchmarking?
                  </li>
                  <li>
                   Jetpack Benchmark library
                  </li>
                  <li>
                   Integration with Android Studio
                  </li>
                  <li>
                   Benchmark configuration
                  </li>
                  <li>
                   Factors affecting Benchmarking
                  </li>
                  <li>
                   Don’t Benchmark everything
                  </li>
                  <li>
                   Closing notes
                  </li>
                 </ol>
                 <p class="graf--p">
                  So, have your coffee with you because this is going to be a long blog and then enjoy the coffee with some Benchmark flavor in it. Let’s get started.
                 </p>
                 <h4 class="graf--h3">
                  Code Measurement
                 </h4>
                 <p class="graf--p">
                  Apart from the hardware of devices, the performance of an Android application is also dependent on the algorithm that you have used in your application. Choosing the right algorithm and data structures should always be your priority. These are micro-optimization that can be done in your app with the help of these changes. So, to make sure your application performs well across a wide variety of devices, please ensure your code is efficient at all levels and this will optimize your performance.
                 </p>
                 <p class="graf--p">
                  You shouldn’t write the code that your application doesn’t need. Also, please don’t allocate the memory if you can avoid it. Some of the tips for writing efficient code can be:
                 </p>
                 <ol>
                  <li>
                   <b class="graf--bold">
                    Unnecessary Object:
                   </b>
                   Avoid creating unnecessary objects because when you create more objects in your app then more memory is taken by the app.
                  </li>
                  <li>
                   <b class="graf--bold">
                    Prefer static over virtual:
                   </b>
                   Using static method over virtual can be 15–20% faster. So, try to use that when you don’t need to access an object’s fields.
                  </li>
                  <li>
                   <b class="graf--bold">
                    Use for-each loop:
                   </b>
                   Instead of using a normal for loop or other loops, prefer using the enhanced for loop i.e. the for-each loop for collections that implement the Iterable interface and for arrays.
                  </li>
                  <li>
                   <b class="graf--bold">
                    Avoid using floating-point:
                   </b>
                   Try to avoid using floating-points because they are 2x slower than the integer on Android devices.
                  </li>
                 </ol>
                 <p class="graf--p">
                  So, these are some of the tips that can be used to improve code performance. But how can I judge the difference between the time taken earlier with my old code and the time taken now with the improved code? So is there any way to measure the code performance? Is there any way to measure how much time it takes to run a chunk of code? Yes the answer is called Benchmarking. But before moving on to Benchmarking, let’s look at some naive solution to calculate the time taken by a chunk of code to run.
                 </p>
                 <pre><code class="language-java graf graf--code">@Test
fun codeMeasurement() {
    val worker = TestListenableWorkerBuilder&lt;MyWorker&gt;(context).build() //jetpack workmanager library
    val start = java.lang.System.nanoTime() //for starting time of work
    worker.doWork() //do some work i.e. code to be measured
    val elapsed = (java.lang.System.nanoTime() - start) //time taken to complete the work
    Log.d("Code Measurement", "Time taken was $elapsed ns")
}</code></pre>
                 <p class="graf--p">
                  Here, in the above example, we are calculating the time taken to do the work by subtracting the end time with the start time. But the problem here is that, we will get different results every time we run the same code duw to various hardware and software problems. So, instead of taking one value, we can apply one loop and find the average of the same to get the elapsed time.
                 </p>
                 <pre><code class="language-java graf graf--code">@Test
fun codeMeasurement() {
    val worker = TestListenableWorkerBuilder&lt;MyWorker&gt;(context).build() //jetpack workmanager library
    val COUNT = 5 //some iteration count
    val start = java.lang.System.nanoTime() //for starting time of work
    for (i in 0..COUNT) {
        worker.doWork() //do some work i.e. code to be measured
    }
    // include outliers
    val elapsed = (java.lang.System.nanoTime() - start) / COUNT //average time taken to complete the work
    Log.d("Code Measurement", "Time taken was $elapsed ns")
}</code></pre>
                 <p class="graf--p">
                  Here, we are having some COUNT number equals to 5 and we take the average of 5 values and then compute the time taken. But why only 5? Why can’t any other number? Also, there can be outliers or various other things that are running in the background and this will affect the measurement time.
                 </p>
                 <p class="graf--p">
                  So, from the above two examples, we can conclude that it is very difficult to measure the code performance because to find the average time taken we need to find how many times we should run the loop i.e. what should be the value of that COUNT variable? It is very tricky. These code measurement steps are called Benchmarking. Let’s dive deeper into it.
                 </p>
                 <h4 class="graf--h3">
                  What is Benchmarking?
                 </h4>
                 <p class="graf--p">
                  Form the previous section, I think you all have an idea about Benchmarking.
                 </p>
                 <p class="graf--p">
                  <b class="graf--bold">
                   We can say that Benchmarking is a process that is used to measure how fast your phone can run something in it. The idea is to put your phone to enough stress so that you can find the maximum performance of your app on your phone.
                  </b>
                 </p>
                 <p class="graf--p">
                  So, in the previous section, we have seen how we can find or measure the average time taken by a piece of code to run in a device. But there were some issues with it. They are:
                 </p>
                 <ol>
                  <li>
                   It is often inaccurate because we are measuring the wrong thing in the wrong time.
                  </li>
                  <li>
                   It is very unstable i.e. if we run the same code several times then chances are there that we get different values for each run.
                  </li>
                  <li>
                   If we are taking out the average of all the values then how to decide the number of times that particular code will be executed before taking the result. You can’t decide this.
                  </li>
                 </ol>
                 <p class="graf--p">
                  So, it’s hard to say how much time we are saving here because Benchmark is very tricky. Is there any option to find the real-time that a piece of code is taking during execution?
                 </p>
                 <blockquote class="graf--blockquote">
                  If there is a Problem then there must be some solution
                 </blockquote>
                 <p class="graf--p">
                  And the solution to our problem is the
                  <b class="graf--bold">
                   Jetpack Benchmark Library
                  </b>
                  :)
                 </p>
                 <h4 class="graf--h3">
                  The Jetpack Benchmark Library
                 </h4>
                 <p class="graf--p">
                  At the Google I/O’19, Android introduced the Jetpack Benchmark Library that can be used to remove all the error or difficulties that we were facing while naively doing the Benchmark process.
                 </p>
                 <p class="graf--p">
                  <b class="graf--bold">
                   The Jetpack Benchmark Libray is a tool for measuring code performance and is used to remove those common mistakes that we were doing earlier while using Benchmark. This library handles warmup, measure your code performance and output the result in the console of Android Studio.
                  </b>
                 </p>
                 <p class="graf--p">
                  Now, the Benchmark code that we were measuring after 5 loops will be converted to:
                 </p>
                 <pre><code class="language-java graf graf--code">@get:Rule
val benchmarkRule = BenchmarkRule()

@Test
fun codeMeasurement() {
    val worker = TestListenableWorkerBuilder&lt;MyWorker&gt;(context).build() //jetpack workmanager library
    benchmarkRule.measureRepeated {
        worker.doWork()
    }
}</code></pre>
                 <p class="graf--p">
                  All you need to do is apply
                  <b class="graf--bold">
                   BenchmarkRule
                  </b>
                  and after that, you need to call an API i.e. the
                  <b class="graf--bold">
                   measureRepeated
                  </b>
                  .
                 </p>
                 <p class="graf--p">
                  Now, let’s look into some other example. Here, we are taking the example of
                  <b class="graf--bold">
                   databaseBenchmark
                  </b>
                  . So, in this databaseBenchmark, firstly, we will initialize the database and after that, we will clear all the tables and insert some testing data. After that, we will create our code measuring loop for measuring the code performance that we care about i.e. some database query.
                 </p>
                 <pre><code class="language-java graf graf--code">@get:Rule
val benchmarkRule = BenchmarkRule()

@Test
fun databaseBenchmark() {
    val db = Room.databaseBuilder(...).build()
    db.clearAndInsertTestData()
    benchmarkRule.measureRepeated {
        db.complexQuery()
    }
}</code></pre>
                 <p class="graf--p">
                  But there is some issue with this code. Our query can be cached if we are not changing the values in the database then the query can be cached and we will get different result from the desired one. So, we can put the
                  <b class="graf--bold">
                   db.clearAndInsertTestData()
                  </b>
                  inside the loop and by doing so in every loop we bust the cache and then measure the code that we are interested in. But here also, we are measuring more than what is required because we have one more statement in the loop. So, to remove this we can apply the previous approach i.e. count or find the time taken by
                  <b class="graf--bold">
                   db.clearAndInsertTestData()
                  </b>
                  and then subtract this result with the final output.
                 </p>
                 <pre><code class="language-java graf graf--code">@get:Rule
val benchmarkRule = BenchmarkRule()

@Test
fun databaseBenchmark() {
    val db = Room.databaseBuilder(...).build()
    val pauseOffset = 0L
    benchmarkRule.measureRepeated {
        val start = java.lang.System.nanoTime()
        db.clearAndInsertTestData()
        pauseOffset += java.lang.System.nanoTime() - start
        db.complexQuery()
    }
    Log.d("Benchmark", "databaseBenchmark_offset: $pauseOffset")
}</code></pre>
                 <p class="graf--p">
                  If you are not in a mood to write so many lines of code, then, there is one API available i.e.
                  <b class="graf--bold">
                   runWithTimeDisabled
                  </b>
                  which will do the same but in a precise way.
                 </p>
                 <pre><code class="language-java graf graf--code">@get:Rule
val benchmarkRule = BenchmarkRule()

@Test
fun databaseBenchmark() {
    val db = Room.databaseBuilder(...).build()
    benchmarkRule.measureRepeated {
        runWithTimeDisabled {
            db.clearAndInsertTestData()
        }
        db.complexQuery()
    }
}</code></pre>
                 <p class="graf--p">
                  Isn’t it simple and crisp? So, no more worries. Just use the Jetpack Benchmark Library and you are good to go with the Benchmarking. But how to integrate this in our Android Studio(the warehouse of every application)? Let’s see.
                 </p>
                 <h4 class="graf--h3">
                  Integration with Android Studio
                 </h4>
                 <p class="graf--p">
                  Since the Benchmark Library is in the alpha phase, we need to download the
                  <a class="markup--anchor" href="https://developer.android.com/studio/preview" target="_blank">
                   Android Studio version 3.5
                  </a>
                  or newer. We love modularization in our project and by default, we have app module and lib module. So, to use the Benchmark library, you need to enable the benchmark module and enable the Android Studio template for Benchmarking. Following are the steps to enable the benchmark module in Android Studio:
                 </p>
                 <ol>
                  <li>
                   Download the Android Studio 3.5 version or higher.
                  </li>
                  <li>
                   In Android Studio, click on
                   <b class="graf--bold">
                    Help &gt; Edit Custom Properties
                   </b>
                   .
                  </li>
                  <li>
                   Add the code:
                   <b class="graf--bold">
                    npw.benchmark.template.module=true
                   </b>
                  </li>
                  <li>
                   Save and close the file.
                  </li>
                  <li>
                   Restart Android Studio.
                  </li>
                 </ol>
                 <p class="graf--p">
                  Now, we can make a Benchmark module other that app and lib module. The Benchmark module template will automatically configure settings for Benchmarking. To create a Benchmark module, do the following:
                 </p>
                 <ol>
                  <li>
                   Right-click on your project or module and select
                   <b class="graf--bold">
                    New &gt; Module
                   </b>
                   .
                  </li>
                  <li>
                   Select
                   <b class="graf--bold">
                    Benchmark Module
                   </b>
                   and click
                   <b class="graf--bold">
                    Next
                   </b>
                   .
                  </li>
                  <li>
                   Enter your module name and language(Java/Kotlin) and then click on
                   <b class="graf--bold">
                    Finish
                   </b>
                   .
                  </li>
                 </ol>
                 <p class="graf--p">
                  Image source: Android website
                 </p>
                 <div class="graf-image graf-caption">
                  <img alt="Improving Android app performance with Benchmarking" class="graf-image" src="/images/improving-android-app-performance-with-benchmarking-benchmark-icon.png"/>
                 </div>
                 <p class="graf--p">
                  By following the above steps, a module will be created that is pre-configured for benchmarking, with a benchmark directory added and the
                  <b class="graf--bold">
                   debuggable
                  </b>
                  is set to
                  <b class="graf--bold">
                   false
                  </b>
                  . Here, by setting the debuggable to be false, we prevent using debugger with our tests.
                 </p>
                 <p class="graf--p">
                  To run the benchmark, in the module, navigate to
                  <b class="graf--bold">
                   <i class="graf--italic">
                    benchmark/src/androidTest
                   </i>
                  </b>
                  and then press the
                  <b class="graf--bold">
                   ctrl+shift+F10
                  </b>
                  (or
                  <b class="graf--bold">
                   cmd+shift+R
                  </b>
                  on mac). Here is the result of the same:
                 </p>
                 <p class="graf--p">
                  Image source: Android website
                 </p>
                 <div class="graf-image graf-caption">
                  <img alt="Improving Android app performance with Benchmarking" class="graf-image" src="/images/improving-android-app-performance-with-benchmarking-benchmark-output.png"/>
                 </div>
                 <h4 class="graf--h3">
                  Benchmark Configuration
                 </h4>
                 <p class="graf--p">
                  Since we are making a module for Benchmark and with any module we have one
                  <b class="graf--bold">
                   <i class="graf--italic">
                    build.gradle
                   </i>
                  </b>
                  file. Same is with the benchmark module. The
                  <b class="graf--bold">
                   <i class="graf--italic">
                    build.gradle
                   </i>
                  </b>
                  file of benchmark consists of:
                 </p>
                 <ol>
                  <li>
                   <b class="graf--bold">
                    The benchmark plugin:
                   </b>
                   It will help you to pull your benchmark reports when you run gradlew.
                  </li>
                  <li>
                   <b class="graf--bold">
                    Custom runner:
                   </b>
                   Custom runner i.e. the AndroidbenchmarkRunner will help to stabilize your benchmark.
                  </li>
                  <li>
                   <b class="graf--bold">
                    Pre-built proguard rules:
                   </b>
                   This optimizes your code
                  </li>
                  <li>
                   <b class="graf--bold">
                    The library itself
                   </b>
                   (alpha version, as of now)
                  </li>
                 </ol>
                 <p class="graf--p">
                  The code of the
                  <b class="graf--bold">
                   <i class="graf--italic">
                    build.gradle
                   </i>
                  </b>
                  file looks like:
                 </p>
                 <pre><code class="language-java graf graf--code">apply plugin: 'com.android.library'
apply plugin: 'androidx.benchmark'

android {
    defaultConfig {
        testInstrumentationRunner "androidx.benchmark.junit4.AndroidBenchmarkRunner"
    }

    buildTypes {
        debug {
            debuggable false
            minifyEnabled true
            proguardFiles getDefaultProguardFile(
                    'proguard-android-optimize.txt'),
                    'benchmark-proguard-rules.pro'
        }
    }
}

dependencies {
    ...
    androidTestImplementation "androidx.benchmark:benchmark-junit4:1.0.0-alpha05"

}</code></pre>
                 <p class="graf--p">
                  Also, in the
                  <b class="graf--bold">
                   <i class="graf--italic">
                    AndoridManifest.xml
                   </i>
                  </b>
                  file, you need to set the debuggable to be false.
                 </p>
                 <pre><code class="language-java graf graf--code">&lt;!-- Important: disable debuggable for accurate performance results --&gt;
&lt;application
    android:debuggable="false"
    tools:replace="android:debuggable"/&gt;</code></pre>
                 <p class="graf--p">
                  You need to set the debuggable to false so that you can prevent the debugger to use your test. Here is a quick difference between the two i.e. when the debuggable is set to true and when it is set to false.
                 </p>
                 <p class="graf--p">
                  Image source: Google I/O'19
                 </p>
                 <div class="graf-image graf-caption">
                  <img alt="Improving Android app performance with Benchmarking" class="graf-image" src="/images/improving-android-app-performance-with-benchmarking-debuggable-comparision.png"/>
                 </div>
                 <p class="graf--p">
                  Apart from the debuggable, you can also set the
                  <b class="graf--bold">
                   codeCoverageEnabled to false
                  </b>
                  .
                 </p>
                 <p class="graf--p">
                  So, we are done with benchmarking. But here is one question, can we use the Jetpack benchmark Library in every situation i.e. is the library producing the same result in every case? The answer is no. But don’t worry, the library will inform you if something is affecting the benchmark. Yes, we have warnings in the benchmark library. So, next time when your debuggable is set to true or you are using emulator or missing some runner or if you are low on battery then the benchmark will give you some warning and you can look out on it and fix it before benchmarking.
                 </p>
                 <h4 class="graf--h3">
                  Factors affecting Benchmarking
                 </h4>
                 <p class="graf--p">
                  Performing a benchmark task is not that easy as it seems to be. There are various enemies to it and the greatest one is the CPU clock. The CPU clock is very responsible for stability. To be more precise, the CPU clock problem is further divided into two problems i.e.
                 </p>
                 <ol>
                  <li>
                   <b class="graf--bold">
                    Ramping
                   </b>
                  </li>
                  <li>
                   <b class="graf--bold">
                    Throttling
                   </b>
                  </li>
                 </ol>
                 <p class="graf--p">
                  <b class="graf--bold">
                   Ramping
                  </b>
                 </p>
                 <p class="graf--p">
                  We all know that when the device is in ideal situation i.e. no work is being assigned then the clock is low and when some task is assigned to it then it starts ramping to high-performance mode. So, in general, clocks will generally increase under load.
                 </p>
                 <p class="graf--p">
                  So, if we are measuring under these two situations then we are likely to get a wrong output for the code measurement because the clock is different in these cases.
                 </p>
                 <p class="graf--p">
                  The solution to this problem is very simple and it is present in the definition of benchmarking. The Benchmark library runs warmup to stabilize this i.e. the loop of benchmarking will run for a minimum of 250ms and after that, the measurement will be done. So, if the clock is in a low state then in that 250ms, the clock will come into the preferred state and the measurement will be taken.
                 </p>
                 <p class="graf--p">
                  Cool, we are done with the first problem. No, it is not cool, it is hot and our second problem also arises due to the temperature of the device.
                 </p>
                 <p class="graf--p">
                  <b class="graf--bold">
                   Diving or Throttling
                  </b>
                 </p>
                 <p class="graf--p">
                  When your device is working so much then it gets hotter and the clock dives quickly. In general, the CPU lowers the clock when the device is hot to avoid damage to the chips. This is also called thermal throttling. So, this can massively affect the benchmark performance because on a certain instance the clock is very high and at the next instance the clock is very low. Following is an example of Thermal Throttling (red line):
                 </p>
                 <p class="graf--p">
                  Image source: Google I/O'19
                 </p>
                 <div class="graf-image graf-caption">
                  <img alt="Improving Android app performance with Benchmarking" class="graf-image" src="/images/improving-android-app-performance-with-benchmarking-cpu-clock.png"/>
                 </div>
                 <p class="graf--p">
                  Here, at one instance, we have a lot to do and the CPU clock is high. But at the same time when the device gets hot, the CPU lowers the clock and after some time due to the pending work, the clock again goes to high. So, we can’t trust the measurements taken in between these clock cycles.
                 </p>
                 <p class="graf--p">
                  There are various solutions to this Thermal Throttling problem. They are:
                 </p>
                 <ol>
                  <li>
                   Clock Locking
                  </li>
                  <li>
                   Sustained Prefernce
                  </li>
                  <li>
                   Thread.sleep()
                  </li>
                 </ol>
                 <p class="graf--p">
                  One solution can be clock locking. So, you can
                  <b class="graf--bold">
                   Lock Clock
                  </b>
                  and then measure the code. But this is not ideal as it requires the device to be in rooted form. Also, we have some gradle plugin to lock clock i.e.
                 </p>
                 <pre><code class="language-java graf graf--code">./gradlew lockClocks</code></pre>
                 <p class="graf--p">
                  But this requires the device to be
                  <b class="graf--bold">
                   rooted
                  </b>
                  . So, this is not a general solution.
                 </p>
                 <p class="graf--p">
                  Another solution is
                  <b class="graf--bold">
                   Sustained preference.
                  </b>
                  There is an API called
                  <b class="graf--bold">
                   Window.setSustainedPerformanceMode()
                  </b>
                  which is generally made for VR/games and it can be used in benchmarking because it lowers the max clocks which prevent throttling. But this also has some demerits:
                 </p>
                 <ol>
                  <li>
                   It requires Activity that is running with some flag set.
                  </li>
                  <li>
                   It can work in single or multithreaded mode.
                  </li>
                  <li>
                   Lastly, it supports only a limited number of devices.
                  </li>
                 </ol>
                 <p class="graf--p">
                  So, let’s find the solution to these three problems.
                 </p>
                 <p class="graf--p">
                  For the Activity flag part, what we do is we inject an Activity whenever we are testing something and after that, we set a flag on all the activities that the user has launched. By doing so our Activity flag difficulty can be solved.
                 </p>
                 <p class="graf--p">
                  For the Single and Multithreaded problem, we have to force the device to the multi-threaded mode because either you can use one core at a max clock or multiple cores at the lower clock. But switching modes can result in inconsistency. So, we should force the device to multi-threaded mode. To do the same, in our AndroidBenchmarkRunner, sustained performance mode is in use, we create a new thread that will spin. This is the best way to force into the multi-threaded mode.
                 </p>
                 <pre><code class="language-java graf graf--code">//AndroidBenchmarkRunner.kt

override fun onCreate(arguments: Bundle) {
    super.onCreate(arguments)

    if(sustainedPerformanceModeInUse) {
        thread(name = "BenchSpinThread") {
            Process.setThreadPriority(Process.THREAD_PRIORITY_LOWEST)
            while(true) {}
        }
    }
}</code></pre>
                 <p class="graf--p">
                  Now, the third and the last problem is that the
                  <b class="graf--bold">
                   Window.setSustainedPerformanceMode()
                  </b>
                  is available only for a limited number of devices. So, to check if your device supports this or not, you can do so by:
                 </p>
                 <pre><code class="language-java graf graf--code">PowerManager.isSustainedPerformanceModeSupported()</code></pre>
                 <p class="graf--p">
                  So, till now we have seen two methods i.e. Clock Locking and Sustained Preference, but both of these methods can’t be used in the normal case because all devices are not rooted and also all devices don’t support Sustained Performance Mode. We need some concrete and general solution. So, here is the final solution for throttling i.e thread sleeping and this the simplest solution.
                 </p>
                 <p class="graf--p">
                  In the
                  <b class="graf--bold">
                   Thread.sleep()
                  </b>
                  method, we detect a slowdown by running a tiny-mini benchmark in between every benchmark to see if the device has started thermal throttling or not. If there is a thermal throttling then we discard the current benchmark data and we sleep to let the device cool down.
                 </p>
                 <p class="graf--p">
                  Below is the comparison of the clock before and after using
                  <b class="graf--bold">
                   Thread.sleep()
                  </b>
                  .(blue line represents the situation after using Thread.sleep())
                 </p>
                 <p class="graf--p">
                  Image source: Google I/O'19
                 </p>
                 <div class="graf-image graf-caption">
                  <img alt="Improving Android app performance with Benchmarking" class="graf-image" src="/images/improving-android-app-performance-with-benchmarking-cpu-clock.png"/>
                 </div>
                 <p class="graf--p">
                  But because we are sleeping whenever there is a thermal throttling, the runtime will be increased due to
                  <b class="graf--bold">
                   Thread.sleep()
                  </b>
                  .
                 </p>
                 <p class="graf--p">
                  Image source: Google I/O'19
                 </p>
                 <div class="graf-image graf-caption">
                  <img alt="Improving Android app performance with Benchmarking" class="graf-image" src="/images/improving-android-app-performance-with-benchmarking-thread-slepp-runtime.png"/>
                 </div>
                 <h4 class="graf--h3">
                  Don’t Benchmark everything
                 </h4>
                 <p class="graf--p">
                  We have seen that with the help of benchmarking we can measure the code performance but it is recommended that we shouldn’t benchmark everything. Start with tracing or profiling tools or you can perform some measurement on your real device that tells you which particular part of your device is slow. If you are benchmarking then you should benchmark synchronous and small blocks.
                 </p>
                 <p class="graf--p">
                  Also, before using a benchmark, you should be aware of the caches that are present in your code. Here is a simple example of a benchmark that loads a file and checks if it exists or not.
                 </p>
                 <pre><code class="language-java graf graf--code">@get:Rule
val benchmarkRule = BenchmarkRule()

@Test
fun myBenchmark() {
    val file = File(path)
    benchmarkRule.measureRepeated {
        file.exists()
    }
}</code></pre>
                 <p class="graf--p">
                  In the above code, the OS will note the address of the file and it will assume that nothing will be changed. So, it will be there in the cache and every time you will be served a cache value. So, the benchmark will be very different from the startup time. Keep a note of these things.
                 </p>
                 <h4 class="graf--h3">
                  Closing Notes
                 </h4>
                 <p class="graf--p">
                  We have seen that Benchmark is a very complex problem i.e. it is very hard to measure the code performance normally. It depends on the Clock Stability. So, to solve these problems we have Jetpack Benchmark Library API that can measure the code performance for you. And remember one thing, Do Not Compare Devices with JetPack Benchmark. Here, we are comparing code written for the same device and same OS version. To learn more about benchmark, you can visit the
                  <a class="markup--anchor" href="https://developer.android.com/studio/profile/benchmark" target="_blank">
                   Benchmark website
                  </a>
                  and for benchmark code samples, you can visit the
                  <a class="markup--anchor" href="https://github.com/googlesamples/android-performance" target="_blank">
                   Github page
                  </a>
                  . Hope you learned something new today.
                 </p>
                 <p class="graf--p">
                  Do share this blog with your fellow developers to spread the knowledge. You can read more blogs on Android on our
                  <a class="markup--anchor" href="https://blog.mindorks.com/" target="_blank">
                   blogging website
                  </a>
                  .
                 </p>
                 <p class="graf--p">
                  <b class="graf--bold">
                   <a class="markup--anchor" href="https://bootcamp.mindorks.com/" target="_blank">
                    Apply Now: MindOrks Android Online Course and Learn Advanced Android
                   </a>
                  </b>
                 </p>
                 <p class="graf--p">
                  Happy Learning :)
                 </p>
                 <p class="graf--p">
                  <b class="graf--bold">
                   Team MindOrks!
                  </b>
                 </p>
                </div>
               </div>
              </div>
             </section>
            </div>
           </div>
          </div>
         </article>
        </div>
       </div>
       <div class="ui divider">
       </div>
      </div>
      <div class="stretched fourteen wide computer fifteen wide mobile fifteen wide tablet column">
       <div class="ui large center aligned header" style="padding-top:20px">
        Recommended for You
       </div>
      </div>
      <div class="fourteen wide computer fifteen wide mobile fifteen wide tablet column">
       <div class="ui centered grid">
        <div class="stretched five wide computer sixteen wide mobile eight wide tablet column">
         <a class="ui fluid card" href="/integrating-android-google-re-captcha-in-android-app/">
          <img alt="Integrating Android Google’s reCAPTCHA in Android App" class="ui centered image" src="/images/integrating-android-google-re-captcha-in-android-app-banner-d717bffad515418a.png" style="max-height:300px"/>
          <div class="content">
           <div class="header">
            Integrating Android Google’s reCAPTCHA in Android App
           </div>
           <div class="meta">
            18th July 2019
           </div>
           <div class="description">
            In this blog, we will learn how to implement Google's reCAPTCHA in our Android application. reCAPTCHA is used to verify if the user is a Human Begin or some robot or bot.
           </div>
          </div>
         </a>
        </div>
        <div class="stretched five wide computer sixteen wide mobile eight wide tablet column">
         <a class="ui fluid card" href="/implementing-in-app-updates-on-android/">
          <img alt="Implementing in-app updates on Android" class="ui centered image" src="/images/in-app-updates-android-banner.png" style="max-height:300px"/>
          <div class="content">
           <div class="header">
            Implementing in-app updates on Android
           </div>
           <div class="meta">
            25th May 2019
           </div>
           <div class="description">
            In this blog, we will learn about the in-app update feature in your Android app. In-app update is a feature that is used to download the update of the app without using the play store. We will see how to use the flexible and immediate in-app update in our app.
           </div>
          </div>
         </a>
        </div>
        <div class="stretched five wide computer sixteen wide mobile eight wide tablet column">
         <a class="ui fluid card" href="/how-to-build-a-modular-android-app-architecture/">
          <img alt="How to build a Modular Android App Architecture?" class="ui centered image" src="/images/banner-modular-arch.png" style="max-height:300px"/>
          <div class="content">
           <div class="header">
            How to build a Modular Android App Architecture?
           </div>
           <div class="meta">
            19th August 2019
           </div>
           <div class="description">
            In this blog, we will learn how can we Build a Modular Android App Architecture. We will learn about dynamic-feature and dynamic delivery. We will also learn how can we use a library module to modularise the app's architecture
           </div>
          </div>
         </a>
        </div>
        <div class="stretched five wide computer sixteen wide mobile eight wide tablet column">
         <a class="ui fluid card" href="/integrating-expression-search-in-android-app/">
          <img alt="Integrating Expression Search in Android app" class="ui centered image" src="/images/integrating-expression-search-in-android-app-banner.png" style="max-height:300px"/>
          <div class="content">
           <div class="header">
            Integrating Expression Search in Android app
           </div>
           <div class="meta">
            4th October 2019
           </div>
           <div class="description">
            In this blog, we will learn how to integrate expression search in Android application. We will learn how to use GIFs for better user communication in our application. We will cover every aspect of it.
           </div>
          </div>
         </a>
        </div>
        <div class="stretched five wide computer sixteen wide mobile eight wide tablet column">
         <a class="ui fluid card" href="/implement-in-app-purchases-in-android/">
          <img alt="Implement In-App Purchases in Android" class="ui centered image" src="/images/banner-in-app-purchase.png" style="max-height:300px"/>
          <div class="content">
           <div class="header">
            Implement In-App Purchases in Android
           </div>
           <div class="meta">
            16th October 2019
           </div>
           <div class="description">
            In this blog, we will talk about how to implement and setup you android app for in app purchase.
           </div>
          </div>
         </a>
        </div>
        <div class="stretched five wide computer sixteen wide mobile eight wide tablet column">
         <a class="ui fluid card" href="/how-to-add-uber-car-animation-in-android-app/">
          <img alt="How to Add Uber Car Animation in Android App?" class="ui centered image" src="/images/how-to-add-uber-car-animation-in-android-app-banner.jpg" style="max-height:300px"/>
          <div class="content">
           <div class="header">
            How to Add Uber Car Animation in Android App?
           </div>
           <div class="meta">
            2nd April 2020
           </div>
           <div class="description">
            In this tutorial, we will learn how to add Uber-like Car Animation in Android App. We will be using Google Map for showing the Car moving from Origin to Destination.
           </div>
          </div>
         </a>
        </div>
       </div>
      </div>
     </div>
    </div>
    <div style="background:#fff">
     <footer class="content-container">
      <div class="ui centered padded grid" style="padding-top:40px;background:linear-gradient(to right,#c4e0e0,#e5f1f1)">
       <h2 class="ui huge icon center aligned header">
        <div class="content">
         Connect With Your Mentors
        </div>
       </h2>
       <div class="centered row">
        <div class="five wide computer sixteen wide mobile eight wide tablet column">
         <div class="ui centered padded one column grid">
          <div class="ui centered grid">
           <div class="column">
            <div class="ui circular segment" style="width:175px;height:175px;padding:0">
             <img alt="Janishar Ali" class="ui medium circular image" src="/assets/ali.jpg"/>
            </div>
           </div>
          </div>
          <div class="column">
           <div class="ui large center aligned header">
            <a class="content" href="https://janisharali.com" target="_blank">
             Janishar Ali
             <div class="sub header" style="padding:5px;color:#000">
              Founder | IIT-BHU | 10 Yrs Exp.
             </div>
            </a>
           </div>
          </div>
          <div class="ui centered grid">
           <div class="column">
            <a class="ui black huge circular icon button" href="https://janisharali.com" role="button" target="_blank">
             <i aria-hidden="true" class="linkify icon">
             </i>
            </a>
            <a class="ui twitter huge circular icon button" href="https://twitter.com/janisharali" role="button" target="_blank">
             <i aria-hidden="true" class="twitter icon">
             </i>
            </a>
           </div>
          </div>
         </div>
        </div>
        <div class="five wide computer sixteen wide mobile eight wide tablet column">
         <div class="ui centered padded one column grid">
          <div class="ui centered grid">
           <div class="column">
            <div class="ui circular segment" style="width:175px;height:175px;padding:0">
             <img alt="Amit Shekhar" class="ui medium circular image" src="/assets/amit.jpg"/>
            </div>
           </div>
          </div>
          <div class="column">
           <div class="ui large center aligned header">
            <a class="content" href="https://amitshekhar.me" target="_blank">
             Amit Shekhar
             <div class="sub header" style="padding:5px;color:#000">
              Founder | IIT-BHU | 10 Yrs Exp.
             </div>
            </a>
           </div>
          </div>
          <div class="ui centered grid">
           <div class="column">
            <a class="ui black huge circular icon button" href="https://amitshekhar.me" role="button" target="_blank">
             <i aria-hidden="true" class="linkify icon">
             </i>
            </a>
            <a class="ui twitter huge circular icon button" href="https://twitter.com/amitiitbhu" role="button" target="_blank">
             <i aria-hidden="true" class="twitter icon">
             </i>
            </a>
           </div>
          </div>
         </div>
        </div>
       </div>
      </div>
      <div class="ui divider" style="margin:unset">
      </div>
      <h5 class="ui header" style="padding:16px;margin:unset;color:#555">
       <i aria-hidden="true" class="copyright icon">
       </i>
       <div class="content">
        Copyright 2022, MindOrks Nextgen Private Limited
       </div>
      </h5>
     </footer>
    </div>
   </div>
  </div>
  <script type="text/javascript">
   window.hljs.initHighlightingOnLoad()
  </script>
 </body>
</html>