<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns#" xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <title>
   Android ViewModels: Under the hood
  </title>
  <meta charset="utf-8"/>
  <meta content="IE=edge" http-equiv="X-UA-Compatible"/>
  <meta content="minimum-scale=1,initial-scale=1,width=device-width,shrink-to-fit=no" name="viewport"/>
  <link href="https://blog.mindorks.com/android-viewmodels-under-the-hood" rel="canonical"/>
  <meta content="986249072156-dabps0lf90smluddrk5rkqsdjghk3hd3.apps.googleusercontent.com" name="google-signin-client_id"/>
  <meta content="android, learn android app development, android app development courses, android blogs, android tutorial" name="keywords"/>
  <meta content="Android ViewModels: Under the hood" property="og:title"/>
  <meta content="website" property="og:type"/>
  <meta content="https://blog.mindorks.com/android-viewmodels-under-the-hood" property="og:url"/>
  <meta content="/images/banner-viewmodels-under-the-hood-226d57476c566b3e.jpg" property="og:image"/>
  <meta content="In this article, we are going to discuss the internals of  ViewModel which is a part of Android Architecture Components. We will first briefly discuss the usages of ViewModel in Android and then we will go in detail about how ViewModel actually works and how it retains itself on configuration changes." property="og:description"/>
  <meta content="Android ViewModels: Under the hood" property="twitter:title"/>
  <meta content="In this article, we are going to discuss the internals of  ViewModel which is a part of Android Architecture Components. We will first briefly discuss the usages of ViewModel in Android and then we will go in detail about how ViewModel actually works and how it retains itself on configuration changes." name="twitter:description"/>
  <meta content="/images/banner-viewmodels-under-the-hood-226d57476c566b3e.jpg" name="twitter:image:src"/>
  <meta content="summary_large_image" name="twitter:card"/>
  <meta content="@MindorksNextGen" name="twitter:site"/>
  <meta content="In this article, we are going to discuss the internals of  ViewModel which is a part of Android Architecture Components. We will first briefly discuss the usages of ViewModel in Android and then we will go in detail about how ViewModel actually works and how it retains itself on configuration changes." name="description"/>
  <meta content="1620001391374687" property="fb:app_id"/>
  <link href="/styles/vendor-1.8.6.css" rel="stylesheet" type="text/css"/>
  <link href="/styles/app-1.8.6.css" rel="stylesheet" type="text/css"/>
  <link as="style" href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.1/css/font-awesome.min.css" onload='this.onload=null,this.rel="stylesheet"' rel="preload"/>
  <noscript>
   <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.1/css/font-awesome.min.css" rel="stylesheet" type="text/css"/>
  </noscript>
  <script type="text/javascript">
   window.__PRELOADED_STATE__={toastr:{toastrs:[],confirm:null},blogData:{data:{},latestBlogs:null,isFetching:!0,isFetchingLatestBlogs:!1,currentCategory:"",categories:[]},contactData:{formData:{email:"",name:"",phone:"",message:"",isWriting:!1,isNameError:!1,isEmailError:!1,isPhoneError:!1,isMessageError:!1,dismissMsg:!1},successMessage:null,errorMessage:null,isSending:!1},communityData:{formData:{email:"",isEmailError:!1,isWriting:!1,isSending:!1,dismissMsg:!1},successMessage:null,errorMessage:null},blogPageData:{blogId:492,data:{id:492,title:"Android ViewModels: Under the hood",description:"In this article, we are going to discuss the internals of  ViewModel which is a part of Android Architecture Components. We will first briefly discuss the usages of ViewModel in Android and then we will go in detail about how ViewModel actually works and how it retains itself on configuration changes.",text:'<h1 class="graf--h1">Android ViewModels: Under the hood</h1> <div class=\'graf-image graf-caption\'>\n\t\t\t\t\t\t\t\t\t<img src=/images/banner-viewmodels-under-the-hood-226d57476c566b3e.jpg class=\'graf-image\' alt=\'Android ViewModels: Under the hood\' />\n\t\t\t\t\t\t\t\t</div ><p class="graf--p">In this article, we are going to discuss the internals of ViewModel which is a part of Android Architecture Components. We will first briefly discuss the usages of ViewModel in Android and then we will go in detail about how ViewModel actually works and how it retains itself on configuration changes.</p><p class="graf--p">According to the <a class="markup--anchor" target="_blank" href="https://developer.android.com/topic/libraries/architecture/viewmodel">documentation</a>, the ViewModel class is designed to store and manage UI-related data in a lifecycle conscious way. The ViewModel class allows data to survive configuration changes such as screen rotations.</p><p class="graf--p">The <code class="graf--code-inline"><code class="graf--code-inline">ViewModel</code></code> class also helps in implementing <b class="graf--bold">MVVM(Model-View-ViewModel)</b> design pattern which is also the recommended Android app architecture for Android applications by Google.</p><p class="graf--p">Also, there are other various advantages of using <code class="graf--code-inline">ViewModel</code> class provided by Android framework like:</p><ul><li><b class="graf--bold">Handle configuration changes:</b> <code class="graf--code-inline"><code class="graf--code-inline">ViewModel</code></code> objects are automatically retained whenever activity is recreated due to configuration changes.</li><li><b class="graf--bold">Lifecycle Awareness:</b> <code class="graf--code-inline"><code class="graf--code-inline">ViewModel</code></code> objects are also lifecycle-aware. They are automatically cleared when the <code class="graf--code-inline"><code class="graf--code-inline">Lifecycle</code></code> they are observing gets permanently destroyed.</li><li><b class="graf--bold">Data Sharing:</b> Data can be easily shared between fragments in an activity using <code class="graf--code-inline"><code class="graf--code-inline">ViewModels</code></code>.</li><li><b class="graf--bold">Kotlin-Coroutines support:</b> <code class="graf--code-inline"><code class="graf--code-inline">ViewModel</code></code> includes support for <a class="markup--anchor" target="_blank" href="https://amitshekhar.me/blog/kotlin-coroutines">Kotlin-Coroutines</a>. So, they can be easily integrated for any asynchronous processing.</li></ul><h4 class="graf--h3">How ViewModel work internally?</h4><p class="graf--p"><a class="markup--anchor" target="_blank" href="https://github.com/deepanshu42/viewmodel-sample">Link to the sample project</a></p><p class="graf--p">This is the sample project we are going to use for explaining how the <code class="graf--code-inline"><code class="graf--code-inline">viewmodel</code></code> retains itself on configuration changes.</p><p class="graf--p">This is a very simple application with a single activity named <code class="graf--code-inline"><code class="graf--code-inline">MainActivity</code></code> which shows a counter. The counter value is our view state kept inside the <code class="graf--code-inline"><code class="graf--code-inline">CounterViewModel</code></code> using a <code class="graf--code-inline"><code class="graf--code-inline">LiveData</code></code> object. The activity also shows the <code class="graf--code-inline"><code class="graf--code-inline">hashcode</code></code> of the current activity instance.</p><p class="graf--p">On any configuration change, the current activity instance is destroyed and a new instance of the activity is created which makes the <code class="graf--code-inline"><code class="graf--code-inline">hashcode</code></code> to change. But the counter value is retained as we are keeping it inside our <code class="graf--code-inline"><code class="graf--code-inline">ViewModel</code></code> and the <code class="graf--code-inline"><code class="graf--code-inline">viewmodels</code></code> are not destroyed if the activity is getting recreated due to configuration changes.</p><p class="graf--p">The first thought around how <code class="graf--code-inline"><code class="graf--code-inline">viewmodels</code></code> are retained might be that they are stored somewhere at the global(application) level and that’s why they are not destroyed when the activity is recreated. But this assumption is wrong. The viewmodels are stored inside the activity (or <code class="graf--code-inline"><code class="graf--code-inline">FragmentManager</code></code> in case of fragments).</p><p class="graf--p">So let’s discuss how this magic happens and how our <code class="graf--code-inline"><code class="graf--code-inline">viewmodel</code></code> instance is retained even if the activity is recreated.</p><pre><code class="language-java graf graf--code">viewModel = ViewModelProvider(this, ViewModelFactory()).get(CounterViewModel::class.java)</code></pre><p class="graf--p">This is the code to get a <code class="graf--code-inline"><code class="graf--code-inline">viewmodel</code></code> instance in an activity. As we can see, we are getting an instance of <code class="graf--code-inline"><code class="graf--code-inline">ViewModelProvider</code></code> by passing two arguments, our activity instance and an instance of <code class="graf--code-inline"><code class="graf--code-inline">ViewModelFactory</code></code>. Then, we are using this <code class="graf--code-inline"><code class="graf--code-inline">ViewModelProvider</code></code> instance to get our <code class="graf--code-inline"><code class="graf--code-inline">CounterViewModel</code></code> object.</p><blockquote class="graf--blockquote"><i class="graf--italic">Note: In the above example, passing</i> <b class="graf--bold">ViewModelFactory</b> <i class="graf--italic">is redundant as our</i> <b class="graf--bold">CounterViewModel</b> <i class="graf--italic">does not have a parameterized constructor. In case we do not pass</i> <b class="graf--bold">ViewModelFactory,</b> <i class="graf--italic">ViewModelProvider uses a default view model factory.</i></blockquote><p class="graf--p">So the creation of viewmodel involves 2 steps:</p><ol type="1"><li>Creation of <code class="graf--code-inline"><code class="graf--code-inline">ViewModelProvider</code></code></li><li>Getting the instance of <code class="graf--code-inline"><code class="graf--code-inline">Viewmodel</code></code> from <code class="graf--code-inline"><code class="graf--code-inline">ViewModelProvider</code></code></li></ol><h4 class="graf--h3">Creation of <code class="graf--code-inline"><code class="graf--code-inline">ViewModelProvider</code></code></h4><pre><code class="language-java graf graf--code">public ViewModelProvider(@NonNull ViewModelStoreOwner owner, @NonNull Factory factory) {\n    this(owner.getViewModelStore(), factory);\n}</code></pre><p class="graf--p">The constructor of <code class="graf--code-inline"><code class="graf--code-inline">ViewModelProvider</code></code> takes two parameters, <code class="graf--code-inline"><code class="graf--code-inline">ViewModelStoreOwner</code></code> and <code class="graf--code-inline"><code class="graf--code-inline">Factory</code></code>. In our example, the activity is the <code class="graf--code-inline"><code class="graf--code-inline">ViewModelStoreOwner</code></code> and we are passing our own custom factory. <code class="graf--code-inline"><code class="graf--code-inline">ViewModelStoreOwner</code></code> is a simple interface with a single method named <code class="graf--code-inline"><code class="graf--code-inline">getViewModelStore()</code></code></p><pre><code class="language-java graf graf--code">public interface ViewModelStoreOwner {\n    @NonNull\n    ViewModelStore getViewModelStore();\n}</code></pre><p class="graf--p">In the constructor, we are simply getting the <code class="graf--code-inline"><code class="graf--code-inline">ViewModelStore</code></code> from <code class="graf--code-inline"><code class="graf--code-inline">ViewModelStoreOwner</code></code> and passing it to the other constructor where they are just assigned to the respective class members.</p><pre><code class="language-java graf graf--code">public ViewModelProvider(@NonNull ViewModelStore store, @NonNull Factory factory) {\n    mFactory = factory;\n    mViewModelStore = store;\n}</code></pre><p class="graf--p">So now we know that our activity is the <code class="graf--code-inline"><code class="graf--code-inline">ViewModelStoreOwner</code></code> and its the responsibility of our activity to provide the <code class="graf--code-inline"><code class="graf--code-inline">ViewModelStore</code></code>.</p><h4 class="graf--h3">Getting the <code class="graf--code-inline"><code class="graf--code-inline">ViewModel</code></code> from <code class="graf--code-inline"><code class="graf--code-inline">ViewModelProvider</code></code></h4><pre><code class="language-java graf graf--code">public &lt;T extends ViewModel&gt; T get(@NonNull Class&lt;T&gt; modelClass) {\n    String canonicalName = modelClass.getCanonicalName();\n    if (canonicalName == null) {\n        throw new IllegalArgumentException("Local and anonymous classes can not be ViewModels");\n    }\n    return get(DEFAULT_KEY + ":" + canonicalName, modelClass);\n}</code></pre><p class="graf--p">When we invoke <code class="graf--code-inline"><code class="graf--code-inline">get()</code></code> method on our <code class="graf--code-inline"><code class="graf--code-inline">ViewModelProvider</code></code>, it gets the <b class="graf--bold">canonical name</b> of the view model class and creates a key by appending the <b class="graf--bold">canonical name</b> to a <b class="graf--bold"><i class="graf--italic">DEFAULT_KEY</i></b>.</p><pre><code class="language-java graf graf--code">public &lt;T extends ViewModel&gt; T get(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) {\n    ViewModel viewModel = mViewModelStore.get(key);\n\n    if (modelClass.isInstance(viewModel)) {\n        if (mFactory instanceof OnRequeryFactory) {\n            ((OnRequeryFactory) mFactory).onRequery(viewModel);\n        }\n        return (T) viewModel;\n    } else {\n        //noinspection StatementWithEmptyBody\n        if (viewModel != null) {\n            // TODO: log a warning.\n        }\n    }\n    if (mFactory instanceof KeyedFactory) {\n        viewModel = ((KeyedFactory) (mFactory)).create(key, modelClass);\n    } else {\n        viewModel = (mFactory).create(modelClass);\n    }\n    mViewModelStore.put(key, viewModel);\n    return (T) viewModel;\n}</code></pre><p class="graf--p">After creating the key from the model class, it checks the <code class="graf--code-inline"><code class="graf--code-inline">ViewModelStore</code></code> (which is provided by our activity) whether a <code class="graf--code-inline"><code class="graf--code-inline">viewmodel</code></code> instance for the given key is already present or not. If the <code class="graf--code-inline"><code class="graf--code-inline">viewmodel</code></code> is already present, it simply returns the <code class="graf--code-inline"><code class="graf--code-inline">viewmodel</code></code> instance present in <code class="graf--code-inline"><code class="graf--code-inline">ViewModelStore</code></code> and if it’s not present, the <code class="graf--code-inline"><code class="graf--code-inline">ViewModelProvider</code></code> uses the <code class="graf--code-inline"><code class="graf--code-inline">Factory</code></code> instance to create a new <code class="graf--code-inline"><code class="graf--code-inline">viewmodel</code></code> object and also stores it in <code class="graf--code-inline"><code class="graf--code-inline">ViewModelStore</code></code>.</p><p class="graf--p">Now we know that our activity is responsible for storing the ViewModel instances. But it’s still a mystery that how these <code class="graf--code-inline"><code class="graf--code-inline">ViewModel</code></code> instances are retained even when the activity instance is recreated on configuration change.</p><h4 class="graf--h3">How ViewModel retain itself?</h4><p class="graf--p">As we saw earlier when we created <code class="graf--code-inline"><code class="graf--code-inline">ViewModelProvider</code></code> we were passing an instance of <code class="graf--code-inline"><code class="graf--code-inline">ViewModelStoreOwner</code></code> i.e., our <code class="graf--code-inline"><code class="graf--code-inline">activity</code></code> instance.</p><pre><code class="language-java graf graf--code">public class ComponentActivity extends androidx.core.app.ComponentActivity implements\n        LifecycleOwner,\n        ViewModelStoreOwner,\n        SavedStateRegistryOwner,\n        OnBackPressedDispatcherOwner</code></pre><p class="graf--p">Our activity implements the <code class="graf--code-inline"><code class="graf--code-inline">ViewModelStoreOwner</code></code> the interface which has a single method named <code class="graf--code-inline"><code class="graf--code-inline">getViewModelStore()</code></code></p><pre><code class="language-java graf graf--code">public interface ViewModelStoreOwner {\n    @NonNull\n    ViewModelStore getViewModelStore();\n}</code></pre><p class="graf--p">Now let’s have a look at the implementation of this method.</p><pre><code class="language-java graf graf--code">@NonNull\n@Override\npublic ViewModelStore getViewModelStore() {\n    if (getApplication() == null) {\n        throw new IllegalStateException("Your activity is not yet attached to the "\n                + "Application instance. You can\'t request ViewModel before onCreate call.");\n    }    //This is true when invoked for the first time\n    if (mViewModelStore == null) {\n        NonConfigurationInstances nc =\n                (NonConfigurationInstances) getLastNonConfigurationInstance();\n        if (nc != null) {\n            // Restore the ViewModelStore from NonConfigurationInstances\n            mViewModelStore = nc.viewModelStore;\n        }\n        if (mViewModelStore == null) {\n            mViewModelStore = new ViewModelStore();\n        }\n    }\n    return mViewModelStore;\n}</code></pre><p class="graf--p">Here we can see that <code class="graf--code-inline"><code class="graf--code-inline">getViewModelStore()</code></code> returns the <b class="graf--bold"><code class="graf--code-inline"><code class="graf--code-inline">mViewModelStore</code></code>.</b> When our activity is recreated due to any configuration change, <code class="graf--code-inline"><code class="graf--code-inline">nc(NonConfigurationInstances)</code></code> contains the previous instance of <code class="graf--code-inline"><code class="graf--code-inline">ViewModelStore</code></code>. <code class="graf--code-inline"><code class="graf--code-inline">nc(NonConfigurationInstances)</code></code> is null when our activity is created for the first time and a new <code class="graf--code-inline">ViewModelStore</code> is created in this case.</p><pre><code class="language-java graf graf--code">//ComponentActivity.java\nstatic final class NonConfigurationInstances {\n    Object custom;\n    ViewModelStore viewModelStore;\n}//Activity.java\nstatic final class NonConfigurationInstances {\n    Object activity;  //NonConfigurationInstances(ComponentActivity)\n    HashMap&lt;String, Object&gt; children;\n    FragmentManagerNonConfig fragments;\n    ArrayMap&lt;String, LoaderManager&gt; loaders;\n    VoiceInteractor voiceInteractor;\n}</code></pre><p class="graf--p"><code class="graf--code-inline"><code class="graf--code-inline">NonConfigurationInstances(Activity.java)</code></code> is the object which is retained by the Android system even when the activity gets recreated. It has a member named <code class="graf--code-inline"><code class="graf--code-inline">activity</code></code> which is an instance of <code class="graf--code-inline"><code class="graf--code-inline">NonConfigurationInstances(ComponentActivity.java)</code></code>. This instance contains <code class="graf--code-inline"><code class="graf--code-inline">ViewModelStore</code></code>.</p><blockquote class="graf--blockquote"><i class="graf--italic">Note:</i> <i class="graf--italic"><code class="graf--code-inline"><code class="graf--code-inline">ViewModels</code></code></i> <i class="graf--italic">are not retained directly. Instead,</i> <i class="graf--italic"><code class="graf--code-inline"><code class="graf--code-inline">ViewModelStore</code></code></i> <i class="graf--italic">is retained on configuration changes which internally maintains a map of</i> <i class="graf--italic"><code class="graf--code-inline"><code class="graf--code-inline">viewmodels</code></code>.</i></blockquote><p class="graf--p">Let’s deep dive more into this.</p><pre><code class="language-java graf graf--code">//Activity.java\npublic Object getLastNonConfigurationInstance() {\n    return mLastNonConfigurationInstances != null\n            ? mLastNonConfigurationInstances.activity : null;\n}//ComponentActivity.java\npublic final Object onRetainNonConfigurationInstance() {\n    Object custom = onRetainCustomNonConfigurationInstance();\n\n    ViewModelStore viewModelStore = mViewModelStore;\n    if (viewModelStore == null) {\n        // No one called getViewModelStore(), so see if there was an existing\n        // ViewModelStore from our last NonConfigurationInstance\n        NonConfigurationInstances nc =\n                (NonConfigurationInstances) getLastNonConfigurationInstance();\n        if (nc != null) {\n            viewModelStore = nc.viewModelStore;\n        }\n    }\n\n    if (viewModelStore == null && custom == null) {\n        return null;\n    }\n\n    NonConfigurationInstances nci = new NonConfigurationInstances();\n    nci.custom = custom;\n    nci.viewModelStore = viewModelStore;\n    return nci;\n}</code></pre><p class="graf--p">Whenever our activity is getting recreated due to any configuration change, <code class="graf--code-inline"><code class="graf--code-inline">onRetainNonConfigurationInstance()</code></code> gets invoked which returns the <code class="graf--code-inline"><code class="graf--code-inline">NonConfigurationInstances(ComponentActivity.java)</code></code> instance. This object is retained by the Android system so that it can be delivered to the next activity instance on recreation.</p><p class="graf--p">Similarly, we can also retain our own custom objects by implementing the <code class="graf--code-inline"><code class="graf--code-inline">onRetainCustomNonConfigurationInstance()</code></code>.</p><p class="graf--p">After the recreation of our activity, <code class="graf--code-inline"><code class="graf--code-inline">NonConfigurationInstances(Activity.java)</code></code> is received in the <code class="graf--code-inline"><code class="graf--code-inline">attach(</code>)</code> method of the <code class="graf--code-inline"><code class="graf--code-inline">Activity</code></code> class.</p><pre><code class="language-java graf graf--code">final void attach(Context context, ActivityThread aThread,\n        Instrumentation instr, IBinder token, int ident,\n        Application application, Intent intent, ActivityInfo info,\n        CharSequence title, Activity parent, String id,\n        NonConfigurationInstances lastNonConfigurationInstances,\n        Configuration config, String referrer, IVoiceInteractor voiceInteractor,\n        Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken)</code></pre><p class="graf--p">This is how the <code class="graf--code-inline"><code class="graf--code-inline">viewmodels</code></code> are retained on configuration changes.</p><p class="graf--p">You can also connect with me on <span class=""><a class="markup--anchor" target="_blank" href="https://www.linkedin.com/in/deepanshu42/">LinkedIn</a></span>, <span class=""><a class="markup--anchor" target="_blank" href="https://twitter.com/deep1743">Twitter</a></span>, <span class=""><a class="markup--anchor" target="_blank" href="https://www.facebook.com/deepanshu42">Facebook</a></span> and <span class=""><a class="markup--anchor" target="_blank" href="https://github.com/deepanshu42">Github</a></span>.<br/></p><p class="graf--p">Thank You!!!</p>',author:14040,img_url:"/images/banner-viewmodels-under-the-hood-226d57476c566b3e.jpg",blog_url:"android-viewmodels-under-the-hood",likes:0,rank:0,category:1,published_at:"6th July 2020"},author:{id:14040,name:"Deepanshu",google_profile_pic:"https://lh6.googleusercontent.com/-0TQ3Ffy_SrU/AAAAAAAAAAI/AAAAAAAAAAA/AMZuucmSiX_h9XkfKNdYgwBAOyAwFkDZSw/s96-c/photo.jpg?sz=300",fb_profile_pic:null,profile_tagline:"Software Engineer - Android",fb_profile_url:"https://www.facebook.com/deepanshu42",google_plus_profile_url:null,twitter_profile_url:"https://twitter.com/deep1743",github_profile_url:"https://github.com/deepanshu42",linkedin_profile_url:"https://www.linkedin.com/in/deepanshu42/"},isFetching:!1,similarBlogs:[{id:247,title:"Exploring Android ViewPager2 in Android",description:"As Google introduced a new ViewPager called the ViewPager2 with some cool features like vertical orientation, use of Recycler View and many more. So, in this blog, we will explore the new ViewPager2 with its implementation as well . ",author:14897,img_url:"/images/exploring-android-viewpager2-banner.png",blog_url:"exploring-android-view-pager2-in-android",likes:0,rank:0,category:1,published_at:"29th May 2019",score:.01835518702864647},{id:254,title:"Android KTX - Android development with Kotlin",description:"In this blog, we will learn how to implement the Android KTX feature of the Android Jetpack that was announced in the Google I/O 2018. We will learn how Kotlin will help us to write the same code and use the same APIs used in Java in a much easier and faster way.",author:14897,img_url:"/images/android-ktx-android-development-banner.png",blog_url:"android-ktx-android-development-with-kotlin",likes:0,rank:0,category:1,published_at:"27th May 2019",score:.01835518702864647},{id:274,title:"Implementing Easy Permissions in Android: Android Tutorial",description:"In this blog, we will learn how to implement Easy Permissions in Android. Easy Permissions are used to ask for permissions required by the application explicitly. These are used to ask users for permissions that are dangerous in nature and involves user privacy.",author:14897,img_url:"/images/implementing-easy-permissions-android-banner.png",blog_url:"implementing-easy-permissions-in-android-android-tutorial",likes:0,rank:0,category:1,published_at:"13th June 2019",score:.01835518702864647},{id:284,title:"Animation in Android - Android Tutorial",description:"In this blog, we will learn how to use Animation in our Andoird Application. Animations are used to convey the message in a better way. It helps in improving the user experience. So, this blog is all about Animations in Android. So, let's learn about Animation.",author:14897,img_url:"/images/animation-in-android-banner.png",blog_url:"animation-in-android-tutorial",likes:0,rank:0,category:1,published_at:"24th June 2019",score:.01835518702864647},{id:297,title:"Integrating Android Google’s reCAPTCHA in Android App",description:"In this blog, we will learn how to implement Google's reCAPTCHA in our Android application. reCAPTCHA is used to verify if the user is a Human Begin or some robot or bot.",author:17146,img_url:"/images/integrating-android-google-re-captcha-in-android-app-banner-d717bffad515418a.png",blog_url:"integrating-android-google-re-captcha-in-android-app",likes:0,rank:0,category:1,published_at:"18th July 2019",score:.01835518702864647},{id:351,title:"Using Android Sensors: Android Tutorial",description:"In this blog, we will learn how to use Android Sensors. There are various sensors present in our Android device and we can use them in our application. For example, we can use the temperature sensor in some weather app. So, let's learn about Android Sensors.",author:14897,img_url:"/images/using-android-sensors-android-tutorial-banner.png",blog_url:"using-android-sensors-android-tutorial",likes:0,rank:0,category:1,published_at:"30th September 2019",score:.01835518702864647}],isSimilarBlogsFetching:!1},loginData:{data:null,isLoggingIn:!1,isLoggingOut:!1,loginState:!1,isForcedLogout:!1,isTokenRefreshed:!1,isRedirectHome:!1,message:""},updatesData:{news:null,inspirations:null,isNewsFetching:!0,isInspirationsFetching:!0},blogEditorData:{blogId:null,blogDetailsFormData:{title:"",description:"",imgUrl:"",blogUrl:"",category:"",categories:[],isWriting:!1,isTitleError:!1,isDescriptionError:!1,isImgUrlError:!1,isBlogUrlError:!1,isCategoryError:!1,isUploadingImage:!1,uploadedImageUrl:null},editorState:null,editorText:null,successMessage:null,errorMessage:null,isSending:!1,isMsgToShow:!1,isPublished:!1,isSubmitted:!1,isDraft:!0,isEditOfExistingBlog:!1,isFetchingBlogCategories:!1,isUploadingImage:!1,uploadedImageUrl:null},myBlogsData:{data:null,isSubmittedBlogsFetching:!0,isDraftBlogsFetching:!0,isPublishedBlogsFetching:!0,successMessage:null,errorMessage:null,isMsgToShow:!1,tabNames:["drafts","submissions","published"],selectedTab:"drafts",isFetchingBlog:!1,isDeletingBlog:!1,openEditorPage:!1},profilePreviewData:{profile:null,blogs:null,isFetchingProfile:!1,isFetchingAuthorBlogs:!1,successMessage:null,errorMessage:null,isMsgToShow:!1,isUserNotRegistered:!1,redirectToMyProfileEdit:!1},profileEditableData:{userId:null,name:null,fbProfilePicUrl:null,googleProfilePicUrl:null,profileFormData:{tagline:"",fbProfileUrl:"",googlePlusProfileUrl:"",twitterProfileUrl:"",githubProfileUrl:"",linkedinProfileUrl:"",isWriting:!1,isTaglineError:!1,isFbProfileUrlError:!1,isGooglePlusProfileUrlError:!1,isTwitterProfileUrlError:!1,isGithubProfileUrlError:!1,isLinkedinProfileUrlError:!1},isSavingProfile:!1,successMessage:null,errorMessage:null,isMsgToShow:!1,redirectToProfilePreview:!1},submitBlogData:{formData:{email:"",name:"",link:"",isWriting:!1,isNameError:!1,isEmailError:!1,isLinkError:!1,dismissMsg:!1},successMessage:null,errorMessage:null,isSubmitting:!1},advertisementsData:{data:{},isLoading:!1},recaptchaData:{verified:!1,successMessage:null,errorMessage:null},blogSearchData:{searches:null,isSearching:!1}}
  </script>
  <script async="" src="https://www.google-analytics.com/analytics.js" type="text/javascript">
  </script>
  <script type="text/javascript">
   window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-91686131-1","auto"),ga("require","cleanUrlTracker"),ga("require","eventTracker"),ga("require","impressionTracker"),ga("require","outboundLinkTracker"),ga("require","urlChangeTracker"),ga("require","maxScrollTracker"),ga("require","mediaQueryTracker"),ga("require","outboundFormTracker"),ga("require","outboundLinkTracker"),ga("require","pageVisibilityTracker"),ga("require","socialWidgetTracker"),ga("require","urlChangeTracker"),ga("send","pageview")
  </script>
  <script defer="defer" src="/assets/autotrack.js" type="text/javascript">
  </script>
  <script src="/assets/highlight.js" type="text/javascript">
  </script>
  <script defer="defer" src="/js/vendor-bundle-1.8.6.js" type="text/javascript">
  </script>
  <script defer="defer" src="/js/app-bundle-1.8.6.js" type="text/javascript">
  </script>
 </head>
 <body>
  <div id="root">
   <div class="screen app-load-content" data-reactroot="">
    <div class="ui centered grid">
     <div class="row" style="padding:0">
      <div class="ui fixed menu navbar huge borderless grid" style="background-color:#fff;height:60px">
      </div>
     </div>
     <div class="centered computer only row" style="padding:0">
      <div class="ui fixed top menu navbar huge borderless grid header-container" style="background-color:#fff;height:60px">
       <a class="item brand" href="/">
        <img alt="MindOrks" src="/assets/mindorks-logo.svg"/>
        <div class="header item" style="font-size:20px;padding:0;margin-left:10px">
         MindOrks
        </div>
       </a>
       <div class="right menu">
        <a class="item" href="https://janisharali.com" target="_blank">
         Mentor Ali
        </a>
        <a class="item" href="https://amitshekhar.me" target="_blank">
         Mentor Amit
        </a>
       </div>
      </div>
     </div>
     <div class="tablet only mobile only row" style="padding:0">
      <div class="ui fixed top navbar huge menu borderless" style="background-color:#fff;height:60px">
       <a class="item brand" href="/">
        <img alt="MindOrks" src="/assets/mindorks-logo.svg"/>
        <div class="header item" style="font-size:20px;padding:0;margin-left:10px">
         MindOrks
        </div>
       </a>
       <div class="item">
       </div>
      </div>
     </div>
    </div>
    <div class="header-height">
    </div>
    <div aria-live="assertive" class="redux-toastr">
     <div>
      <div class="top-left">
      </div>
      <div class="top-right">
      </div>
      <div class="top-center">
      </div>
      <div class="bottom-left">
      </div>
      <div class="bottom-right">
      </div>
      <div class="bottom-center">
      </div>
     </div>
    </div>
    <div class="content-container theme">
     <div class="ui centered one column grid" style="padding-bottom:80px;background-color:#fff">
      <div class="ten wide computer fifteen wide mobile fifteen wide tablet column" style="margin-top:50px">
       <div>
        <div class="blog-page-author">
         <div class="ui small header">
          <img alt="Deepanshu" class="ui circular image" src="https://lh6.googleusercontent.com/-0TQ3Ffy_SrU/AAAAAAAAAAI/AAAAAAAAAAA/AMZuucmSiX_h9XkfKNdYgwBAOyAwFkDZSw/s96-c/photo.jpg?sz=300"/>
          <div class="content">
           Deepanshu
           <div class="sub header" style="margin-top:5px">
            6th July 2020
           </div>
          </div>
         </div>
        </div>
        <div id="content">
         <article class="template">
          <div class="postContent">
           <div class="notesSource">
            <div class="postField postField--body" id="editor">
             <section class="section--first section--last">
              <div class="section-divider layoutSingleColumn-template">
               <hr class="section-divider"/>
              </div>
              <div class="section-content">
               <div class="section-inner layoutSingleColumn-template">
                <div>
                 <h1 class="graf--h1">
                  Android ViewModels: Under the hood
                 </h1>
                 <div class="graf-image graf-caption">
                  <img alt="Android ViewModels: Under the hood" class="graf-image" src="/images/banner-viewmodels-under-the-hood-226d57476c566b3e.jpg"/>
                 </div>
                 <p class="graf--p">
                  In this article, we are going to discuss the internals of ViewModel which is a part of Android Architecture Components. We will first briefly discuss the usages of ViewModel in Android and then we will go in detail about how ViewModel actually works and how it retains itself on configuration changes.
                 </p>
                 <p class="graf--p">
                  According to the
                  <a class="markup--anchor" href="https://developer.android.com/topic/libraries/architecture/viewmodel" target="_blank">
                   documentation
                  </a>
                  , the ViewModel class is designed to store and manage UI-related data in a lifecycle conscious way. The ViewModel class allows data to survive configuration changes such as screen rotations.
                 </p>
                 <p class="graf--p">
                  The
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    ViewModel
                   </code>
                  </code>
                  class also helps in implementing
                  <b class="graf--bold">
                   MVVM(Model-View-ViewModel)
                  </b>
                  design pattern which is also the recommended Android app architecture for Android applications by Google.
                 </p>
                 <p class="graf--p">
                  Also, there are other various advantages of using
                  <code class="graf--code-inline">
                   ViewModel
                  </code>
                  class provided by Android framework like:
                 </p>
                 <ul>
                  <li>
                   <b class="graf--bold">
                    Handle configuration changes:
                   </b>
                   <code class="graf--code-inline">
                    <code class="graf--code-inline">
                     ViewModel
                    </code>
                   </code>
                   objects are automatically retained whenever activity is recreated due to configuration changes.
                  </li>
                  <li>
                   <b class="graf--bold">
                    Lifecycle Awareness:
                   </b>
                   <code class="graf--code-inline">
                    <code class="graf--code-inline">
                     ViewModel
                    </code>
                   </code>
                   objects are also lifecycle-aware. They are automatically cleared when the
                   <code class="graf--code-inline">
                    <code class="graf--code-inline">
                     Lifecycle
                    </code>
                   </code>
                   they are observing gets permanently destroyed.
                  </li>
                  <li>
                   <b class="graf--bold">
                    Data Sharing:
                   </b>
                   Data can be easily shared between fragments in an activity using
                   <code class="graf--code-inline">
                    <code class="graf--code-inline">
                     ViewModels
                    </code>
                   </code>
                   .
                  </li>
                  <li>
                   <b class="graf--bold">
                    Kotlin-Coroutines support:
                   </b>
                   <code class="graf--code-inline">
                    <code class="graf--code-inline">
                     ViewModel
                    </code>
                   </code>
                   includes support for
                   <a class="markup--anchor" href="https://amitshekhar.me/blog/kotlin-coroutines" target="_blank">
                    Kotlin-Coroutines
                   </a>
                   . So, they can be easily integrated for any asynchronous processing.
                  </li>
                 </ul>
                 <h4 class="graf--h3">
                  How ViewModel work internally?
                 </h4>
                 <p class="graf--p">
                  <a class="markup--anchor" href="https://github.com/deepanshu42/viewmodel-sample" target="_blank">
                   Link to the sample project
                  </a>
                 </p>
                 <p class="graf--p">
                  This is the sample project we are going to use for explaining how the
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    viewmodel
                   </code>
                  </code>
                  retains itself on configuration changes.
                 </p>
                 <p class="graf--p">
                  This is a very simple application with a single activity named
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    MainActivity
                   </code>
                  </code>
                  which shows a counter. The counter value is our view state kept inside the
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    CounterViewModel
                   </code>
                  </code>
                  using a
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    LiveData
                   </code>
                  </code>
                  object. The activity also shows the
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    hashcode
                   </code>
                  </code>
                  of the current activity instance.
                 </p>
                 <p class="graf--p">
                  On any configuration change, the current activity instance is destroyed and a new instance of the activity is created which makes the
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    hashcode
                   </code>
                  </code>
                  to change. But the counter value is retained as we are keeping it inside our
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    ViewModel
                   </code>
                  </code>
                  and the
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    viewmodels
                   </code>
                  </code>
                  are not destroyed if the activity is getting recreated due to configuration changes.
                 </p>
                 <p class="graf--p">
                  The first thought around how
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    viewmodels
                   </code>
                  </code>
                  are retained might be that they are stored somewhere at the global(application) level and that’s why they are not destroyed when the activity is recreated. But this assumption is wrong. The viewmodels are stored inside the activity (or
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    FragmentManager
                   </code>
                  </code>
                  in case of fragments).
                 </p>
                 <p class="graf--p">
                  So let’s discuss how this magic happens and how our
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    viewmodel
                   </code>
                  </code>
                  instance is retained even if the activity is recreated.
                 </p>
                 <pre><code class="language-java graf graf--code">viewModel = ViewModelProvider(this, ViewModelFactory()).get(CounterViewModel::class.java)</code></pre>
                 <p class="graf--p">
                  This is the code to get a
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    viewmodel
                   </code>
                  </code>
                  instance in an activity. As we can see, we are getting an instance of
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    ViewModelProvider
                   </code>
                  </code>
                  by passing two arguments, our activity instance and an instance of
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    ViewModelFactory
                   </code>
                  </code>
                  . Then, we are using this
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    ViewModelProvider
                   </code>
                  </code>
                  instance to get our
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    CounterViewModel
                   </code>
                  </code>
                  object.
                 </p>
                 <blockquote class="graf--blockquote">
                  <i class="graf--italic">
                   Note: In the above example, passing
                  </i>
                  <b class="graf--bold">
                   ViewModelFactory
                  </b>
                  <i class="graf--italic">
                   is redundant as our
                  </i>
                  <b class="graf--bold">
                   CounterViewModel
                  </b>
                  <i class="graf--italic">
                   does not have a parameterized constructor. In case we do not pass
                  </i>
                  <b class="graf--bold">
                   ViewModelFactory,
                  </b>
                  <i class="graf--italic">
                   ViewModelProvider uses a default view model factory.
                  </i>
                 </blockquote>
                 <p class="graf--p">
                  So the creation of viewmodel involves 2 steps:
                 </p>
                 <ol type="1">
                  <li>
                   Creation of
                   <code class="graf--code-inline">
                    <code class="graf--code-inline">
                     ViewModelProvider
                    </code>
                   </code>
                  </li>
                  <li>
                   Getting the instance of
                   <code class="graf--code-inline">
                    <code class="graf--code-inline">
                     Viewmodel
                    </code>
                   </code>
                   from
                   <code class="graf--code-inline">
                    <code class="graf--code-inline">
                     ViewModelProvider
                    </code>
                   </code>
                  </li>
                 </ol>
                 <h4 class="graf--h3">
                  Creation of
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    ViewModelProvider
                   </code>
                  </code>
                 </h4>
                 <pre><code class="language-java graf graf--code">public ViewModelProvider(@NonNull ViewModelStoreOwner owner, @NonNull Factory factory) {
    this(owner.getViewModelStore(), factory);
}</code></pre>
                 <p class="graf--p">
                  The constructor of
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    ViewModelProvider
                   </code>
                  </code>
                  takes two parameters,
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    ViewModelStoreOwner
                   </code>
                  </code>
                  and
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    Factory
                   </code>
                  </code>
                  . In our example, the activity is the
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    ViewModelStoreOwner
                   </code>
                  </code>
                  and we are passing our own custom factory.
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    ViewModelStoreOwner
                   </code>
                  </code>
                  is a simple interface with a single method named
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    getViewModelStore()
                   </code>
                  </code>
                 </p>
                 <pre><code class="language-java graf graf--code">public interface ViewModelStoreOwner {
    @NonNull
    ViewModelStore getViewModelStore();
}</code></pre>
                 <p class="graf--p">
                  In the constructor, we are simply getting the
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    ViewModelStore
                   </code>
                  </code>
                  from
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    ViewModelStoreOwner
                   </code>
                  </code>
                  and passing it to the other constructor where they are just assigned to the respective class members.
                 </p>
                 <pre><code class="language-java graf graf--code">public ViewModelProvider(@NonNull ViewModelStore store, @NonNull Factory factory) {
    mFactory = factory;
    mViewModelStore = store;
}</code></pre>
                 <p class="graf--p">
                  So now we know that our activity is the
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    ViewModelStoreOwner
                   </code>
                  </code>
                  and its the responsibility of our activity to provide the
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    ViewModelStore
                   </code>
                  </code>
                  .
                 </p>
                 <h4 class="graf--h3">
                  Getting the
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    ViewModel
                   </code>
                  </code>
                  from
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    ViewModelProvider
                   </code>
                  </code>
                 </h4>
                 <pre><code class="language-java graf graf--code">public &lt;T extends ViewModel&gt; T get(@NonNull Class&lt;T&gt; modelClass) {
    String canonicalName = modelClass.getCanonicalName();
    if (canonicalName == null) {
        throw new IllegalArgumentException("Local and anonymous classes can not be ViewModels");
    }
    return get(DEFAULT_KEY + ":" + canonicalName, modelClass);
}</code></pre>
                 <p class="graf--p">
                  When we invoke
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    get()
                   </code>
                  </code>
                  method on our
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    ViewModelProvider
                   </code>
                  </code>
                  , it gets the
                  <b class="graf--bold">
                   canonical name
                  </b>
                  of the view model class and creates a key by appending the
                  <b class="graf--bold">
                   canonical name
                  </b>
                  to a
                  <b class="graf--bold">
                   <i class="graf--italic">
                    DEFAULT_KEY
                   </i>
                  </b>
                  .
                 </p>
                 <pre><code class="language-java graf graf--code">public &lt;T extends ViewModel&gt; T get(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) {
    ViewModel viewModel = mViewModelStore.get(key);

    if (modelClass.isInstance(viewModel)) {
        if (mFactory instanceof OnRequeryFactory) {
            ((OnRequeryFactory) mFactory).onRequery(viewModel);
        }
        return (T) viewModel;
    } else {
        //noinspection StatementWithEmptyBody
        if (viewModel != null) {
            // TODO: log a warning.
        }
    }
    if (mFactory instanceof KeyedFactory) {
        viewModel = ((KeyedFactory) (mFactory)).create(key, modelClass);
    } else {
        viewModel = (mFactory).create(modelClass);
    }
    mViewModelStore.put(key, viewModel);
    return (T) viewModel;
}</code></pre>
                 <p class="graf--p">
                  After creating the key from the model class, it checks the
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    ViewModelStore
                   </code>
                  </code>
                  (which is provided by our activity) whether a
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    viewmodel
                   </code>
                  </code>
                  instance for the given key is already present or not. If the
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    viewmodel
                   </code>
                  </code>
                  is already present, it simply returns the
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    viewmodel
                   </code>
                  </code>
                  instance present in
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    ViewModelStore
                   </code>
                  </code>
                  and if it’s not present, the
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    ViewModelProvider
                   </code>
                  </code>
                  uses the
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    Factory
                   </code>
                  </code>
                  instance to create a new
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    viewmodel
                   </code>
                  </code>
                  object and also stores it in
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    ViewModelStore
                   </code>
                  </code>
                  .
                 </p>
                 <p class="graf--p">
                  Now we know that our activity is responsible for storing the ViewModel instances. But it’s still a mystery that how these
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    ViewModel
                   </code>
                  </code>
                  instances are retained even when the activity instance is recreated on configuration change.
                 </p>
                 <h4 class="graf--h3">
                  How ViewModel retain itself?
                 </h4>
                 <p class="graf--p">
                  As we saw earlier when we created
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    ViewModelProvider
                   </code>
                  </code>
                  we were passing an instance of
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    ViewModelStoreOwner
                   </code>
                  </code>
                  i.e., our
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    activity
                   </code>
                  </code>
                  instance.
                 </p>
                 <pre><code class="language-java graf graf--code">public class ComponentActivity extends androidx.core.app.ComponentActivity implements
        LifecycleOwner,
        ViewModelStoreOwner,
        SavedStateRegistryOwner,
        OnBackPressedDispatcherOwner</code></pre>
                 <p class="graf--p">
                  Our activity implements the
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    ViewModelStoreOwner
                   </code>
                  </code>
                  the interface which has a single method named
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    getViewModelStore()
                   </code>
                  </code>
                 </p>
                 <pre><code class="language-java graf graf--code">public interface ViewModelStoreOwner {
    @NonNull
    ViewModelStore getViewModelStore();
}</code></pre>
                 <p class="graf--p">
                  Now let’s have a look at the implementation of this method.
                 </p>
                 <pre><code class="language-java graf graf--code">@NonNull
@Override
public ViewModelStore getViewModelStore() {
    if (getApplication() == null) {
        throw new IllegalStateException("Your activity is not yet attached to the "
                + "Application instance. You can't request ViewModel before onCreate call.");
    }    //This is true when invoked for the first time
    if (mViewModelStore == null) {
        NonConfigurationInstances nc =
                (NonConfigurationInstances) getLastNonConfigurationInstance();
        if (nc != null) {
            // Restore the ViewModelStore from NonConfigurationInstances
            mViewModelStore = nc.viewModelStore;
        }
        if (mViewModelStore == null) {
            mViewModelStore = new ViewModelStore();
        }
    }
    return mViewModelStore;
}</code></pre>
                 <p class="graf--p">
                  Here we can see that
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    getViewModelStore()
                   </code>
                  </code>
                  returns the
                  <b class="graf--bold">
                   <code class="graf--code-inline">
                    <code class="graf--code-inline">
                     mViewModelStore
                    </code>
                   </code>
                   .
                  </b>
                  When our activity is recreated due to any configuration change,
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    nc(NonConfigurationInstances)
                   </code>
                  </code>
                  contains the previous instance of
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    ViewModelStore
                   </code>
                  </code>
                  .
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    nc(NonConfigurationInstances)
                   </code>
                  </code>
                  is null when our activity is created for the first time and a new
                  <code class="graf--code-inline">
                   ViewModelStore
                  </code>
                  is created in this case.
                 </p>
                 <pre><code class="language-java graf graf--code">//ComponentActivity.java
static final class NonConfigurationInstances {
    Object custom;
    ViewModelStore viewModelStore;
}//Activity.java
static final class NonConfigurationInstances {
    Object activity;  //NonConfigurationInstances(ComponentActivity)
    HashMap&lt;String, Object&gt; children;
    FragmentManagerNonConfig fragments;
    ArrayMap&lt;String, LoaderManager&gt; loaders;
    VoiceInteractor voiceInteractor;
}</code></pre>
                 <p class="graf--p">
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    NonConfigurationInstances(Activity.java)
                   </code>
                  </code>
                  is the object which is retained by the Android system even when the activity gets recreated. It has a member named
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    activity
                   </code>
                  </code>
                  which is an instance of
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    NonConfigurationInstances(ComponentActivity.java)
                   </code>
                  </code>
                  . This instance contains
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    ViewModelStore
                   </code>
                  </code>
                  .
                 </p>
                 <blockquote class="graf--blockquote">
                  <i class="graf--italic">
                   Note:
                  </i>
                  <i class="graf--italic">
                   <code class="graf--code-inline">
                    <code class="graf--code-inline">
                     ViewModels
                    </code>
                   </code>
                  </i>
                  <i class="graf--italic">
                   are not retained directly. Instead,
                  </i>
                  <i class="graf--italic">
                   <code class="graf--code-inline">
                    <code class="graf--code-inline">
                     ViewModelStore
                    </code>
                   </code>
                  </i>
                  <i class="graf--italic">
                   is retained on configuration changes which internally maintains a map of
                  </i>
                  <i class="graf--italic">
                   <code class="graf--code-inline">
                    <code class="graf--code-inline">
                     viewmodels
                    </code>
                   </code>
                   .
                  </i>
                 </blockquote>
                 <p class="graf--p">
                  Let’s deep dive more into this.
                 </p>
                 <pre><code class="language-java graf graf--code">//Activity.java
public Object getLastNonConfigurationInstance() {
    return mLastNonConfigurationInstances != null
            ? mLastNonConfigurationInstances.activity : null;
}//ComponentActivity.java
public final Object onRetainNonConfigurationInstance() {
    Object custom = onRetainCustomNonConfigurationInstance();

    ViewModelStore viewModelStore = mViewModelStore;
    if (viewModelStore == null) {
        // No one called getViewModelStore(), so see if there was an existing
        // ViewModelStore from our last NonConfigurationInstance
        NonConfigurationInstances nc =
                (NonConfigurationInstances) getLastNonConfigurationInstance();
        if (nc != null) {
            viewModelStore = nc.viewModelStore;
        }
    }

    if (viewModelStore == null &amp;&amp; custom == null) {
        return null;
    }

    NonConfigurationInstances nci = new NonConfigurationInstances();
    nci.custom = custom;
    nci.viewModelStore = viewModelStore;
    return nci;
}</code></pre>
                 <p class="graf--p">
                  Whenever our activity is getting recreated due to any configuration change,
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    onRetainNonConfigurationInstance()
                   </code>
                  </code>
                  gets invoked which returns the
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    NonConfigurationInstances(ComponentActivity.java)
                   </code>
                  </code>
                  instance. This object is retained by the Android system so that it can be delivered to the next activity instance on recreation.
                 </p>
                 <p class="graf--p">
                  Similarly, we can also retain our own custom objects by implementing the
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    onRetainCustomNonConfigurationInstance()
                   </code>
                  </code>
                  .
                 </p>
                 <p class="graf--p">
                  After the recreation of our activity,
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    NonConfigurationInstances(Activity.java)
                   </code>
                  </code>
                  is received in the
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    attach(
                   </code>
                   )
                  </code>
                  method of the
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    Activity
                   </code>
                  </code>
                  class.
                 </p>
                 <pre><code class="language-java graf graf--code">final void attach(Context context, ActivityThread aThread,
        Instrumentation instr, IBinder token, int ident,
        Application application, Intent intent, ActivityInfo info,
        CharSequence title, Activity parent, String id,
        NonConfigurationInstances lastNonConfigurationInstances,
        Configuration config, String referrer, IVoiceInteractor voiceInteractor,
        Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken)</code></pre>
                 <p class="graf--p">
                  This is how the
                  <code class="graf--code-inline">
                   <code class="graf--code-inline">
                    viewmodels
                   </code>
                  </code>
                  are retained on configuration changes.
                 </p>
                 <p class="graf--p">
                  You can also connect with me on
                  <span class="">
                   <a class="markup--anchor" href="https://www.linkedin.com/in/deepanshu42/" target="_blank">
                    LinkedIn
                   </a>
                  </span>
                  ,
                  <span class="">
                   <a class="markup--anchor" href="https://twitter.com/deep1743" target="_blank">
                    Twitter
                   </a>
                  </span>
                  ,
                  <span class="">
                   <a class="markup--anchor" href="https://www.facebook.com/deepanshu42" target="_blank">
                    Facebook
                   </a>
                  </span>
                  and
                  <span class="">
                   <a class="markup--anchor" href="https://github.com/deepanshu42" target="_blank">
                    Github
                   </a>
                  </span>
                  .
                  <br/>
                 </p>
                 <p class="graf--p">
                  Thank You!!!
                 </p>
                </div>
               </div>
              </div>
             </section>
            </div>
           </div>
          </div>
         </article>
        </div>
       </div>
       <div class="ui divider">
       </div>
      </div>
      <div class="stretched fourteen wide computer fifteen wide mobile fifteen wide tablet column">
       <div class="ui large center aligned header" style="padding-top:20px">
        Recommended for You
       </div>
      </div>
      <div class="fourteen wide computer fifteen wide mobile fifteen wide tablet column">
       <div class="ui centered grid">
        <div class="stretched five wide computer sixteen wide mobile eight wide tablet column">
         <a class="ui fluid card" href="/exploring-android-view-pager2-in-android/">
          <img alt="Exploring Android ViewPager2 in Android" class="ui centered image" src="/images/exploring-android-viewpager2-banner.png" style="max-height:300px"/>
          <div class="content">
           <div class="header">
            Exploring Android ViewPager2 in Android
           </div>
           <div class="meta">
            29th May 2019
           </div>
           <div class="description">
            As Google introduced a new ViewPager called the ViewPager2 with some cool features like vertical orientation, use of Recycler View and many more. So, in this blog, we will explore the new ViewPager2 with its implementation as well .
           </div>
          </div>
         </a>
        </div>
        <div class="stretched five wide computer sixteen wide mobile eight wide tablet column">
         <a class="ui fluid card" href="/android-ktx-android-development-with-kotlin/">
          <img alt="Android KTX - Android development with Kotlin" class="ui centered image" src="/images/android-ktx-android-development-banner.png" style="max-height:300px"/>
          <div class="content">
           <div class="header">
            Android KTX - Android development with Kotlin
           </div>
           <div class="meta">
            27th May 2019
           </div>
           <div class="description">
            In this blog, we will learn how to implement the Android KTX feature of the Android Jetpack that was announced in the Google I/O 2018. We will learn how Kotlin will help us to write the same code and use the same APIs used in Java in a much easier and faster way.
           </div>
          </div>
         </a>
        </div>
        <div class="stretched five wide computer sixteen wide mobile eight wide tablet column">
         <a class="ui fluid card" href="/implementing-easy-permissions-in-android-android-tutorial/">
          <img alt="Implementing Easy Permissions in Android: Android Tutorial" class="ui centered image" src="/images/implementing-easy-permissions-android-banner.png" style="max-height:300px"/>
          <div class="content">
           <div class="header">
            Implementing Easy Permissions in Android: Android Tutorial
           </div>
           <div class="meta">
            13th June 2019
           </div>
           <div class="description">
            In this blog, we will learn how to implement Easy Permissions in Android. Easy Permissions are used to ask for permissions required by the application explicitly. These are used to ask users for permissions that are dangerous in nature and involves user privacy.
           </div>
          </div>
         </a>
        </div>
        <div class="stretched five wide computer sixteen wide mobile eight wide tablet column">
         <a class="ui fluid card" href="/animation-in-android-tutorial/">
          <img alt="Animation in Android - Android Tutorial" class="ui centered image" src="/images/animation-in-android-banner.png" style="max-height:300px"/>
          <div class="content">
           <div class="header">
            Animation in Android - Android Tutorial
           </div>
           <div class="meta">
            24th June 2019
           </div>
           <div class="description">
            In this blog, we will learn how to use Animation in our Andoird Application. Animations are used to convey the message in a better way. It helps in improving the user experience. So, this blog is all about Animations in Android. So, let's learn about Animation.
           </div>
          </div>
         </a>
        </div>
        <div class="stretched five wide computer sixteen wide mobile eight wide tablet column">
         <a class="ui fluid card" href="/integrating-android-google-re-captcha-in-android-app/">
          <img alt="Integrating Android Google’s reCAPTCHA in Android App" class="ui centered image" src="/images/integrating-android-google-re-captcha-in-android-app-banner-d717bffad515418a.png" style="max-height:300px"/>
          <div class="content">
           <div class="header">
            Integrating Android Google’s reCAPTCHA in Android App
           </div>
           <div class="meta">
            18th July 2019
           </div>
           <div class="description">
            In this blog, we will learn how to implement Google's reCAPTCHA in our Android application. reCAPTCHA is used to verify if the user is a Human Begin or some robot or bot.
           </div>
          </div>
         </a>
        </div>
        <div class="stretched five wide computer sixteen wide mobile eight wide tablet column">
         <a class="ui fluid card" href="/using-android-sensors-android-tutorial/">
          <img alt="Using Android Sensors: Android Tutorial" class="ui centered image" src="/images/using-android-sensors-android-tutorial-banner.png" style="max-height:300px"/>
          <div class="content">
           <div class="header">
            Using Android Sensors: Android Tutorial
           </div>
           <div class="meta">
            30th September 2019
           </div>
           <div class="description">
            In this blog, we will learn how to use Android Sensors. There are various sensors present in our Android device and we can use them in our application. For example, we can use the temperature sensor in some weather app. So, let's learn about Android Sensors.
           </div>
          </div>
         </a>
        </div>
       </div>
      </div>
     </div>
    </div>
    <div style="background:#fff">
     <footer class="content-container">
      <div class="ui centered padded grid" style="padding-top:40px;background:linear-gradient(to right,#c4e0e0,#e5f1f1)">
       <h2 class="ui huge icon center aligned header">
        <div class="content">
         Connect With Your Mentors
        </div>
       </h2>
       <div class="centered row">
        <div class="five wide computer sixteen wide mobile eight wide tablet column">
         <div class="ui centered padded one column grid">
          <div class="ui centered grid">
           <div class="column">
            <div class="ui circular segment" style="width:175px;height:175px;padding:0">
             <img alt="Janishar Ali" class="ui medium circular image" src="/assets/ali.jpg"/>
            </div>
           </div>
          </div>
          <div class="column">
           <div class="ui large center aligned header">
            <a class="content" href="https://janisharali.com" target="_blank">
             Janishar Ali
             <div class="sub header" style="padding:5px;color:#000">
              Founder | IIT-BHU | 10 Yrs Exp.
             </div>
            </a>
           </div>
          </div>
          <div class="ui centered grid">
           <div class="column">
            <a class="ui black huge circular icon button" href="https://janisharali.com" role="button" target="_blank">
             <i aria-hidden="true" class="linkify icon">
             </i>
            </a>
            <a class="ui twitter huge circular icon button" href="https://twitter.com/janisharali" role="button" target="_blank">
             <i aria-hidden="true" class="twitter icon">
             </i>
            </a>
           </div>
          </div>
         </div>
        </div>
        <div class="five wide computer sixteen wide mobile eight wide tablet column">
         <div class="ui centered padded one column grid">
          <div class="ui centered grid">
           <div class="column">
            <div class="ui circular segment" style="width:175px;height:175px;padding:0">
             <img alt="Amit Shekhar" class="ui medium circular image" src="/assets/amit.jpg"/>
            </div>
           </div>
          </div>
          <div class="column">
           <div class="ui large center aligned header">
            <a class="content" href="https://amitshekhar.me" target="_blank">
             Amit Shekhar
             <div class="sub header" style="padding:5px;color:#000">
              Founder | IIT-BHU | 10 Yrs Exp.
             </div>
            </a>
           </div>
          </div>
          <div class="ui centered grid">
           <div class="column">
            <a class="ui black huge circular icon button" href="https://amitshekhar.me" role="button" target="_blank">
             <i aria-hidden="true" class="linkify icon">
             </i>
            </a>
            <a class="ui twitter huge circular icon button" href="https://twitter.com/amitiitbhu" role="button" target="_blank">
             <i aria-hidden="true" class="twitter icon">
             </i>
            </a>
           </div>
          </div>
         </div>
        </div>
       </div>
      </div>
      <div class="ui divider" style="margin:unset">
      </div>
      <h5 class="ui header" style="padding:16px;margin:unset;color:#555">
       <i aria-hidden="true" class="copyright icon">
       </i>
       <div class="content">
        Copyright 2022, MindOrks Nextgen Private Limited
       </div>
      </h5>
     </footer>
    </div>
   </div>
  </div>
  <script type="text/javascript">
   window.hljs.initHighlightingOnLoad()
  </script>
 </body>
</html>